雪花算法 时间 时区 世界时区的划分以本初子午线为标准，向东12个时区，向西12个时区，每个时区（180/12=15度），子午线所在区为0时区，东十二区和西十二区重合，所以一共是24个时区。 GMT GMT（Greenwich Mean Time）， 格林威治平时（也称格林威治时间）。 它规定太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间为中午12点。 1972年之前，格林威治时间（GMT）一直是世界时间的标准。1972年之后，GMT 不再是一个时间标准了。 UTC UTC（Coodinated Universal Time），协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。 UTC 是现在全球通用的时间标准，全球各地都同意将各自的时间进行同步协调。 UTC 时间是经过平均太阳时（以格林威治时间 GMT 为准）、地轴运动修正后的新时标以及以秒为单位的国际原子时所综合精算而成。 GMT vs UTC GMT 是前世界标准时，UTC 是现世界标准时。 UTC 比 GMT 更精准，以原子时计时，适应现代社会的精确计时。 UTC 与 GMT 基本上等同，误差不超过0.9秒。 时间戳 在 Unix 系统中，距离 GMT 时间 1970-01-01 00:00:00（北京时间 1970-01-01 08:00:00）所经过的总秒数（不区分时区），也称 Unix 时间戳。 目前 Unix 时间戳是以 32位二进制数表示，32位二进制数值范围为（-2147483648 ~ +2147483647，2147483647 为 2^31 次方，第1位为符号位，0表示正数，1表示负数），由于系统不支持负的时间戳，因此，目前时间戳能表示的最大时间为 2038-01-19 03:14:07 秒（约68年），该时刻的时间戳为 2147483647。于该时间后，需要扩展 UNIX 时间戳的二进制位数。 毫秒时间戳 1s=1000ms，则毫秒时间戳是在秒级别后增加3位10进制数进行表示，最大为999，换算成二进制是 1111100111，占10bits，则毫秒时间戳共占 31+10=41bits，2^41次方为2199023255552 二进制 机器数 一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1. 比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是0000 0011。如果是 -3 ，就是 10000011 。 那么，这里的 00000011 和 10000011 就是机器数。 真值 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。 例：0000 0001的真值 = 000 0001 = +1，1000 0001的真值 = –000 0001 = –1 原码、反码、补码 对于一个数，计算机要使用一定的编码方式进行存储。原码、反码、补码是机器存储一个具体数字的编码方式。

原码 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制: [+1]原 = 0000 0001 [-1]原 = 1000 0001 第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是: [1111 1111 , 0111 1111] 即 [-127 , 127] 原码是人脑最容易理解和计算的表示方式.
反码 反码的表示方法是: 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反. [+1] = [00000001]原 = [00000001]反 [-1] = [10000001]原 = [11111110]反 可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.
补码 补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) [+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 为何要使用 现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同: [+1] = [00000001]原 = [00000001]反 = [00000001]补 所以不需要过多解释. 但是对于负数原码, 反码和补码是完全不同的: [-1] = [10000001]原 = [11111110]反 = [11111111]补 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了. 于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码: 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数. 为了解决原码做减法的问题, 出现了反码: 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0. 于是补码的出现, 解决了0的符号以及两个编码的问题: 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128: 2 7 128 [-1] (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 -1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的) 使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]. 因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值. 数据库ID 优缺点
自增主键
优点
非常简单，利用数据库自由的功能实现，成本小、性能优异
ID号单调递增，新增、检索效率高
数字型，占用空间小
缺点
当数据量庞大的时候，需要进行分库分表，那么自增ID不能满足唯一ID来标识数据
强依赖DB，不同的数据库语法和实现不同，在数据库迁移时处理起来比较麻烦，如：Mysql 使用 AUTO_INCREMENT 关键字，Oracle 使用序列机制
在单个、读写分离、一主多从数据库的情况下，只有一个主库可以生成，有单点故障的风险
UUID
优点
全局唯一性
使用程序生成，简单、生成效率高
缺点
无序会在数据插入时对原有的索引结构进行很大的修改
32位16进制数字，占用空间大，查询、排序时效率相对较慢
不可读
Redis ID
使用 Redis 在网络IO和键值对读写是单线程特性，生成全局唯一的ID，比如：使用原子操作 INCR、INCRBY命令。
可以使用 Redis 集群来获取更高的吞吐量，假如有3台，每台设置初始值分别是1、2、3，按步长为3的方式递增
优点
不依赖数据库，性能优异于数据库
生成的数据是有序的，对排序业务有利
缺点
没有Redis，需要引入新组件，增加系统复杂度
开发成本高
Redis单点故障，影响序列服务的可用性
Zookeeper ID
使用 znode 数据版本来生成序列号，可以生成32位、64位的数据版本号。
由于需要依赖 ZK，并且是多步调用API，如果在竞争较大的情况下，需要考虑使用分布式锁。因此，性能在高并发的分布式环境下，也不甚理想。
雪花算法
优点
不依赖于数据库等第三方系统
灵活方便，可以根据自身特性分配 bit 位
单机上ID单调递增，毫秒数在高位，自增序列在低位，整个ID都是成趋势递增的
缺点
强依赖机器时钟，如果时钟回拨，会导致发号重复或者服务处于不可用状态
ID可能不是全局递增（在单机上递增），因为涉及到分布式环境，每台机器上的时钟不可能完全同步 雪花算法 [图片] 由 Twitter 公布的分布式主键生成算法，它能够保证不同表的主键不重复性，以及相同表主键的有序性
长度共64bits（4byte，Long类型）
第1位是符号位，1bit标识，由于Long类型在Java中是带符号的，最高位是符号位，正数为0，负数为1，因为 ID 一般为正数，所以最高位固定为0
41bit时间戳（毫秒级），存储的是时间戳的差值（当前时间戳 - 开始时间戳），结果约等于 69.73 年
10bit作为工作进程ID，分为来两部分（前5位是数据中心，后5位位机器Id，2^10次方，共1024个节点）
12bit作为毫秒内的流水号（意味着每个节点在每毫秒内可以产生 2^12次方6 3个ID，共4096个） 最后生成的ID的长度最大为2^63次方（9223372036854776000，19位数字字符）